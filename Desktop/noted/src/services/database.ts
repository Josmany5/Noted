// ============================================
// NOTED - Database Service (SQLite)
// ============================================

import * as SQLite from 'expo-sqlite';
import type {
  Note,
  Entry,
  Folder,
  SavedLink,
  PipelineGroup,
  DeepWorkSession,
  Template,
} from '../types';

const DB_NAME = 'noted.db';

class DatabaseService {
  private db: SQLite.WebSQLDatabase | null = null;

  // ============================================
  // Initialize Database
  // ============================================

  async init() {
    try {
      this.db = SQLite.openDatabase(DB_NAME);
      await this.createTables();
      console.log('✅ Database initialized successfully');
    } catch (error) {
      console.error('❌ Database initialization failed:', error);
      throw error;
    }
  }

  private async createTables() {
    if (!this.db) throw new Error('Database not initialized');

    return new Promise<void>((resolve, reject) => {
      this.db!.transaction((tx) => {
        // Notes table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS notes (
            id TEXT PRIMARY KEY,
            title TEXT NOT NULL,
            createdAt INTEGER NOT NULL,
            lastModified INTEGER NOT NULL,
            folderId TEXT,
            hashtags TEXT,
            linkedNoteIds TEXT,
            urgency TEXT DEFAULT 'none',
            importance INTEGER DEFAULT 0,
            pipelineStage TEXT,
            progressPercentage INTEGER DEFAULT 0,
            pipelineGroupId TEXT,
            totalDeepWorkTime INTEGER DEFAULT 0,
            deepWorkSessionCount INTEGER DEFAULT 0
          )
        `);

        // Entries table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS entries (
            id TEXT PRIMARY KEY,
            noteId TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            content TEXT NOT NULL,
            location TEXT,
            mood TEXT,
            isDeepWorkSession INTEGER DEFAULT 0,
            deepWorkSessionId TEXT,
            isEdited INTEGER DEFAULT 0,
            editHistory TEXT,
            embeddedLinks TEXT,
            imageUrls TEXT,
            FOREIGN KEY (noteId) REFERENCES notes(id) ON DELETE CASCADE
          )
        `);

        // Folders table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS folders (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            parentFolderId TEXT,
            colorHex TEXT,
            icon TEXT,
            isAutoGenerated INTEGER DEFAULT 0,
            createdAt INTEGER NOT NULL
          )
        `);

        // Saved Links table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS savedLinks (
            id TEXT PRIMARY KEY,
            entryId TEXT NOT NULL,
            url TEXT NOT NULL,
            title TEXT NOT NULL,
            description TEXT,
            previewImageUrl TEXT,
            saveMode TEXT DEFAULT 'link_only',
            readerModeContent TEXT,
            highlights TEXT,
            userNotes TEXT,
            hashtags TEXT,
            domain TEXT,
            savedAt INTEGER NOT NULL,
            isFavorite INTEGER DEFAULT 0,
            isRead INTEGER DEFAULT 0,
            isArchived INTEGER DEFAULT 0,
            type TEXT DEFAULT 'other',
            videoDuration INTEGER,
            readTimeMinutes INTEGER,
            FOREIGN KEY (entryId) REFERENCES entries(id) ON DELETE CASCADE
          )
        `);

        // Pipeline Groups table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS pipelineGroups (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            noteIds TEXT,
            currentStage TEXT,
            overallProgress INTEGER DEFAULT 0,
            totalDeepWorkTime INTEGER DEFAULT 0,
            createdAt INTEGER NOT NULL,
            completedAt INTEGER
          )
        `);

        // Deep Work Sessions table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS deepWorkSessions (
            id TEXT PRIMARY KEY,
            noteId TEXT,
            pipelineGroupId TEXT,
            startTime INTEGER NOT NULL,
            endTime INTEGER,
            plannedDuration INTEGER NOT NULL,
            actualDuration INTEGER DEFAULT 0,
            focusDescription TEXT,
            wasCompleted INTEGER DEFAULT 0,
            accomplishment TEXT
          )
        `);

        // Templates table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS templates (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            structure TEXT NOT NULL,
            recurrence TEXT DEFAULT 'none',
            reminderSettings TEXT
          )
        `);

        // Tasks table
        tx.executeSql(`
          CREATE TABLE IF NOT EXISTS tasks (
            id TEXT PRIMARY KEY,
            noteId TEXT NOT NULL,
            description TEXT NOT NULL,
            isCompleted INTEGER DEFAULT 0,
            completedAt INTEGER,
            FOREIGN KEY (noteId) REFERENCES notes(id) ON DELETE CASCADE
          )
        `);

        // Create indexes for faster queries
        tx.executeSql('CREATE INDEX IF NOT EXISTS idx_notes_lastModified ON notes(lastModified)');
        tx.executeSql('CREATE INDEX IF NOT EXISTS idx_notes_urgency ON notes(urgency)');
        tx.executeSql('CREATE INDEX IF NOT EXISTS idx_notes_importance ON notes(importance)');
        tx.executeSql('CREATE INDEX IF NOT EXISTS idx_entries_noteId ON entries(noteId)');
        tx.executeSql('CREATE INDEX IF NOT EXISTS idx_entries_timestamp ON entries(timestamp)');
      }, reject, resolve);
    });
  }

  // ============================================
  // NOTES CRUD Operations
  // ============================================

  async createNote(note: Omit<Note, 'id' | 'entries' | 'tasks'>): Promise<string> {
    const id = `note_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          `INSERT INTO notes (
            id, title, createdAt, lastModified, folderId, hashtags, linkedNoteIds,
            urgency, importance, pipelineStage, progressPercentage, pipelineGroupId,
            totalDeepWorkTime, deepWorkSessionCount
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            id,
            note.title,
            note.createdAt.getTime(),
            note.lastModified.getTime(),
            note.folderId || null,
            JSON.stringify(note.hashtags),
            JSON.stringify(note.linkedNoteIds),
            note.urgency,
            note.importance,
            note.pipelineStage || null,
            note.progressPercentage,
            note.pipelineGroupId || null,
            note.totalDeepWorkTime,
            note.deepWorkSessionCount,
          ],
          () => resolve(id),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async getAllNotes(): Promise<Note[]> {
    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'SELECT * FROM notes ORDER BY lastModified DESC',
          [],
          async (_, { rows }) => {
            const notes: Note[] = [];
            for (let i = 0; i < rows.length; i++) {
              const row = rows.item(i);
              const entries = await this.getEntriesByNoteId(row.id);
              const tasks = await this.getTasksByNoteId(row.id);

              notes.push({
                id: row.id,
                title: row.title,
                createdAt: new Date(row.createdAt),
                lastModified: new Date(row.lastModified),
                folderId: row.folderId,
                hashtags: JSON.parse(row.hashtags || '[]'),
                linkedNoteIds: JSON.parse(row.linkedNoteIds || '[]'),
                urgency: row.urgency,
                importance: row.importance,
                pipelineStage: row.pipelineStage,
                progressPercentage: row.progressPercentage,
                pipelineGroupId: row.pipelineGroupId,
                entries,
                tasks,
                totalDeepWorkTime: row.totalDeepWorkTime,
                deepWorkSessionCount: row.deepWorkSessionCount,
              });
            }
            resolve(notes);
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async getNoteById(id: string): Promise<Note | null> {
    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'SELECT * FROM notes WHERE id = ?',
          [id],
          async (_, { rows }) => {
            if (rows.length === 0) {
              resolve(null);
              return;
            }

            const row = rows.item(0);
            const entries = await this.getEntriesByNoteId(row.id);
            const tasks = await this.getTasksByNoteId(row.id);

            resolve({
              id: row.id,
              title: row.title,
              createdAt: new Date(row.createdAt),
              lastModified: new Date(row.lastModified),
              folderId: row.folderId,
              hashtags: JSON.parse(row.hashtags || '[]'),
              linkedNoteIds: JSON.parse(row.linkedNoteIds || '[]'),
              urgency: row.urgency,
              importance: row.importance,
              pipelineStage: row.pipelineStage,
              progressPercentage: row.progressPercentage,
              pipelineGroupId: row.pipelineGroupId,
              entries,
              tasks,
              totalDeepWorkTime: row.totalDeepWorkTime,
              deepWorkSessionCount: row.deepWorkSessionCount,
            });
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async updateNote(id: string, updates: Partial<Note>): Promise<void> {
    return new Promise((resolve, reject) => {
      const fields: string[] = [];
      const values: any[] = [];

      if (updates.title !== undefined) {
        fields.push('title = ?');
        values.push(updates.title);
      }
      if (updates.lastModified !== undefined) {
        fields.push('lastModified = ?');
        values.push(updates.lastModified.getTime());
      }
      if (updates.urgency !== undefined) {
        fields.push('urgency = ?');
        values.push(updates.urgency);
      }
      if (updates.importance !== undefined) {
        fields.push('importance = ?');
        values.push(updates.importance);
      }
      if (updates.pipelineStage !== undefined) {
        fields.push('pipelineStage = ?');
        values.push(updates.pipelineStage);
      }
      if (updates.progressPercentage !== undefined) {
        fields.push('progressPercentage = ?');
        values.push(updates.progressPercentage);
      }
      if (updates.hashtags !== undefined) {
        fields.push('hashtags = ?');
        values.push(JSON.stringify(updates.hashtags));
      }
      if (updates.linkedNoteIds !== undefined) {
        fields.push('linkedNoteIds = ?');
        values.push(JSON.stringify(updates.linkedNoteIds));
      }

      values.push(id);

      this.db!.transaction((tx) => {
        tx.executeSql(
          `UPDATE notes SET ${fields.join(', ')} WHERE id = ?`,
          values,
          () => resolve(),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async deleteNote(id: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'DELETE FROM notes WHERE id = ?',
          [id],
          () => resolve(),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  // ============================================
  // ENTRIES CRUD Operations
  // ============================================

  async createEntry(noteId: string, entry: Omit<Entry, 'id'>): Promise<string> {
    const id = `entry_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          `INSERT INTO entries (
            id, noteId, timestamp, content, location, mood,
            isDeepWorkSession, deepWorkSessionId, isEdited, editHistory,
            embeddedLinks, imageUrls
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            id,
            noteId,
            entry.timestamp.getTime(),
            entry.content,
            entry.location ? JSON.stringify(entry.location) : null,
            entry.mood ? JSON.stringify(entry.mood) : null,
            entry.isDeepWorkSession ? 1 : 0,
            entry.deepWorkSessionId || null,
            entry.isEdited ? 1 : 0,
            JSON.stringify(entry.editHistory),
            JSON.stringify(entry.embeddedLinks),
            JSON.stringify(entry.imageUrls),
          ],
          () => resolve(id),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async getEntriesByNoteId(noteId: string): Promise<Entry[]> {
    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'SELECT * FROM entries WHERE noteId = ? ORDER BY timestamp ASC',
          [noteId],
          (_, { rows }) => {
            const entries: Entry[] = [];
            for (let i = 0; i < rows.length; i++) {
              const row = rows.item(i);
              entries.push({
                id: row.id,
                timestamp: new Date(row.timestamp),
                content: row.content,
                location: row.location ? JSON.parse(row.location) : undefined,
                mood: row.mood ? JSON.parse(row.mood) : undefined,
                isDeepWorkSession: row.isDeepWorkSession === 1,
                deepWorkSessionId: row.deepWorkSessionId,
                isEdited: row.isEdited === 1,
                editHistory: JSON.parse(row.editHistory || '[]'),
                embeddedLinks: JSON.parse(row.embeddedLinks || '[]'),
                imageUrls: JSON.parse(row.imageUrls || '[]'),
              });
            }
            resolve(entries);
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  // ============================================
  // TASKS CRUD Operations
  // ============================================

  async createTask(noteId: string, description: string): Promise<string> {
    const id = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'INSERT INTO tasks (id, noteId, description, isCompleted) VALUES (?, ?, ?, 0)',
          [id, noteId, description],
          () => resolve(id),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async getTasksByNoteId(noteId: string): Promise<any[]> {
    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'SELECT * FROM tasks WHERE noteId = ?',
          [noteId],
          (_, { rows }) => {
            const tasks = [];
            for (let i = 0; i < rows.length; i++) {
              const row = rows.item(i);
              tasks.push({
                id: row.id,
                description: row.description,
                isCompleted: row.isCompleted === 1,
                completedAt: row.completedAt ? new Date(row.completedAt) : undefined,
              });
            }
            resolve(tasks);
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async toggleTask(taskId: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        // First get current state
        tx.executeSql(
          'SELECT isCompleted FROM tasks WHERE id = ?',
          [taskId],
          (_, { rows }) => {
            if (rows.length > 0) {
              const isCompleted = rows.item(0).isCompleted === 1;
              const newState = !isCompleted;
              const completedAt = newState ? Date.now() : null;

              tx.executeSql(
                'UPDATE tasks SET isCompleted = ?, completedAt = ? WHERE id = ?',
                [newState ? 1 : 0, completedAt, taskId],
                () => resolve(),
                (_, error) => {
                  reject(error);
                  return false;
                }
              );
            }
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  // ============================================
  // FOLDERS CRUD Operations
  // ============================================

  async createFolder(name: string, isAutoGenerated: boolean = false): Promise<string> {
    const id = `folder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'INSERT INTO folders (id, name, isAutoGenerated, createdAt) VALUES (?, ?, ?, ?)',
          [id, name, isAutoGenerated ? 1 : 0, Date.now()],
          () => resolve(id),
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }

  async getAllFolders(): Promise<Folder[]> {
    return new Promise((resolve, reject) => {
      this.db!.transaction((tx) => {
        tx.executeSql(
          'SELECT * FROM folders ORDER BY name ASC',
          [],
          (_, { rows }) => {
            const folders: Folder[] = [];
            for (let i = 0; i < rows.length; i++) {
              const row = rows.item(i);
              folders.push({
                id: row.id,
                name: row.name,
                parentFolderId: row.parentFolderId,
                colorHex: row.colorHex,
                icon: row.icon,
                isAutoGenerated: row.isAutoGenerated === 1,
                createdAt: new Date(row.createdAt),
              });
            }
            resolve(folders);
          },
          (_, error) => {
            reject(error);
            return false;
          }
        );
      });
    });
  }
}

export const db = new DatabaseService();
